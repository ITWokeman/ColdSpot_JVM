******************************************
* 字节码执行引擎                         *
******************************************

  引擎模块调用图



                                                                            运
  J    委托执行程序  ************************************     保存数据      行
  V   ------------→ *                                  * --------------→  时
  M   执行完成，返回 * 解释执行器(由线程调度器调度线程) *     获取数据      数
  入  ←------------ *                                  * ←--------------  据
  口   |----------→ ************************************ ←------------|   区
       |                | 委                        压 |                |
       | 返回指令表     | 托                        入 |                | 
	  *************     | 加                        或 |     ********   |    
	  *           *     | 载                        弹 |     *      *   |
	  * JVM指令集 * ←--| 指                        出 |--→ * 线程 * --|
	  *           *       令                        栈       *      * 完成操作，返回结果，
	  *************       表                        帧       ******** 解释执行器继续执行指令

注：方法栈区属于运行时数据区

一.功能
  提供解释器，用于解释执行方法(即运行Java程序)

  解释执行器是java程序的入口

二.主要对外提供方法
  1.interpreter:	解释执行器。从程序入口即public static void main(String[] args)开始执行程序
					可选择是否显示执行步骤

三.流程
  1.根据方法签名，通过主类的方法加载器获取main方法信息。为了保证是static的，还要利用方法修饰符作判断
  2.创建主线程。根据main方法信息创建main方法栈帧，并压入主线程方法栈栈底
  3.将控制台输入的信息打包成main方法的String[] args参数。存放到main方法的局部变量表
  4.创建Java指令表。将指令数与JVM指令集模块对应的指令执行方法绑定。
  5.开始执行程序。从主线程的方法栈栈底的栈帧开始执行
	[线程调度器调度执行]
	线程调度器调度具体线程执行
    (1) 根据栈帧方法的指令表执行方法
	  ① 根据PC(程序计数)从指令表查询指令
	  ② 根据指令查询指令表，进入对应的指令执行方法
	  ③ 指令执行方法执行相应操作。如栈帧压入，弹出方法、对操作数栈元素进行操作、从局部变量表加载变量、修改PC等
	(2) 判断方法栈帧是否为空。否，PC+1，执行下一条指令;是，程序执行结束

  6.显示执行情况。如加载类的数量、执行时间、执行指令数量、占用堆区大小等



四.内存模型

    方法栈(FrameStack)

     +-------------+ <-- 栈顶
	 |             |
	 +-------------+
	 |             |
	 +-------------+
	 |             |
	 +-------------+    |--> 局部变量表(LocalVarsTable)			存放方法用到的变量
	 |             |    |          
	 +-------------+    |--> 操作数栈(OperateStack)				存放方法操作的变量
	 |             |    |
	 +-------------+    |--> PC(Program Count)					程序计数器。用于计数执行到了那条指令
	 | 栈帧(Frame) | ---|
	 +-------------+    |--> 栈帧方法(Frame Method)				指向当前栈帧操作的方法
							   |
							   |-->指令表(instructionsTable)	存放方法指令。解释器根据指令表解释执行程序

     栈帧:		每个栈帧对应着一个未运行完的函数
	 方法栈:	按先进后出的方式存放栈帧。以此实现方法的调用

五.相关指令
  
  1.方法调用指令:
    (1) invokestatic		调用静态方法
	(2) invokevirtual	调用虚方法，即实例方法
	(3) invokespecial	调用特殊方法。如父类构造方法super、私有方法、构造器和类构造方法
	(4) invokeinterface	调用接口方法。如A a = new B();(A是接口，B是A的实现类)。调用A的实例方法就要使用invokeinterface

  2.返回指令
    (1) ireturn			返回int、byte、char、boolean类型
	(2) freturn			返回float类型
	(3) lreturn			返回long类型
	(4) dreturn			返回double类型
	(5) areturn			返回引用类型

六.调用与返回流程

  假设A类的methodA方法对B类methodB方法进行调用，
  下面是methodA调用执行methodB的完整流程

  1.methodA栈帧将要传入methodB的参数压到methodA的操作数栈
  2.methodA执行到方法调用相关指令并执行
    (1) 根据索引值在运行时常量池找到方法引用
    (2) 根据方法引用在B类的方法加载器查找methodB。若找不到，则去B类父类，父类的父类查找直至找到
    (3) 根据methodB的信息创建methodB栈帧
    (4) methodA将操作数栈的变量弹出，传到methodB的局部变量表，完成参数传递
    (5) 将methodB栈帧压入方法栈
  3.执行methodB
  4.将要返回给methodA的值压入操作数栈
  5.methodB执行到返回相关指令并执行
    (1) 将methodB操作数栈的值传入methodA操作数栈
	(2) 方法栈弹出methodB栈帧
  6.结束操作

七.线程调度器
  
  1.线程状态切换
								Thread thread = new Thread()
											↓  
										+--------+
										|  初始  |                     Object.wait(long)
										|  (NEW) |                     Thread.join(long)
										+--------+                     Thread.sleep(long)
	Object.wait()							↓ thread.start()       LockSupport.parkNanos()
	Thread.join()			 +-----------------------------+        LockSupport.parkUntil()       
  LockSupport.park()		 |		     运     行         |--------------------------                
       ----------------------|			(RUNNABLE)         |                         ↓
	  ↓                     |		 +-------------+       |                 +-----------------+
  +-----------+	             |		 |	 运 行 中  |       |                 |    超时等待     |
  |   等待	  |	             |		 |  (RUNNING)  |       |                 | (TIMED_WAITING) |
  | (WAITING) |	             |       +-------------+       |                 +-----------------+
  +-----------+	             |  系统调度↑     ↓系统调度  |←-------------------------|
	  |  			         |		 +-------------+       |                   Object.notify()
	   --------------------→|		 |	 就    绪  |       |                  Object.notifyAll()
	   Object.notify()	     |		 |    (READY)  |       |               LockSupport.unpark(Thread)
      Object.notifyAll()     |       +-------------+       | 
 LockSupport.unpark(Thread)	 |                             |←------------------------------            
                             +-----------------------------+                               | 获取到锁
                                            ↓ 执行完成  |                           +-----------+
					                  +--------------+   |                           |    阻塞   |
									  |  终      止  |   |-------------------------→| (BLOCKED) |
									  | (TERMINATED) |     等待进入synchronized方法  +-----------+
									  +--------------+     等待进入synchronized块                
									                                     