******************************************
* 类加载执行子系统                       *
******************************************

   系统模块调用图
              
		                            
  外   委托加载类    *******************  委托初始化类     外
  部  ------------→ *                 * ←--------------  部
  模  返回委托加载类 * JVM类加载执行器 *  初始化成功       模
  块  ←------------ *                 * --------------→  块
      ------------→ ******************* ←-------------
      | 返回加载的类文件    | 委   委 |   返回解析结果 |
      |                     | 托   托 |                |
  **********************    | 加   解 |    ********************
  *                    * ←-- 载   析 --→ *                  *
  * .CLASS类文件加载器 *      类   类      * .CLASS文件解析器 *
  *                    *      文   文      *                  *
  **********************      件   件      ********************
                                   字
								   节
								   码

一.功能
  接受外部系统(通常是JVM的方法区)委托加载类信息，
  完成类生命周期过程:载入→验证→准备→解析→初始化→使用→卸载 的前5项

  这里按工作量分为3块
  1..CLASS类文件加载器	:	载入阶段――加载类文件阶段
  2..CLASS文件解析器	:	载入阶段――字节码转换为类结构体
  3.JVM类加载执行器		:	委托1，2完成载入阶段，负责验证、准备、解析和初始化

二.主要对外提供方法
  1.loadNonArrayClass方法:	加载非数组的引用类
  2.loadArrayClass方法:	加载数组类
  3.loadPrimitiveClasses:	加载基本类型

三.流程
  执行流程:载入→验证→准备→解析→初始化

  加载A类，A类的父类，父类的父类也会被递归解析。递归解析的工作在载入~验证间完成。

  1.载入
    (1) class文件链接
      JVM类加载执行器委托.CLASS类文件加载器加载。
	  通过双亲委派机制进行加载:
      ① 应用类加载器(ApplicationClassLoader) 委托 扩展类加载器(ExtensionClassLoader)加载类文件
	  ② 扩展类加载器(ExtensionClassLoader) 委托 启动类加载器(BootstrapClassLoader)加载类文件
	  ③ 启动类加载器(BootstrapClassLoader) 在$JAVA_HOME/jre/lib下查找类文件，返回结果给扩展类加载器
	  ④ 若启动类加载器加载失败，则扩展类加载器$JAVA_HOME/jre/ext查找类文件，返回结果给应用类加载器
      ⑤ 若扩展类加载器加载失败，则应用类加载器在配置文件的CLASSPATH下查找类文件
	  ⑥ 若应用类加载器加载失败，则报错：找不到类文件

                              ----------------
							  | 启动类加载器 |
							  ----------------
					委托加载  ↑            ↓  返回结果
					 ----------------   ----------------
					 | 扩展类加载器 |   | 扩展类加载器 |
					 ----------------   ----------------
					委托加载  ↑            ↓  返回结果
			    ----------------           ----------------
			    | 应用类加载器 |           | 应用类加载器 |
				----------------           ----------------

	(2).class文件解析
	  加载类文件完成后，JVM类加载器委托.CLASS文件解析器将类文件解析成运行时数据区的MethodAreaClass结构(方法区类)。
	  解析完成后主要包含如下信息

	  ① 类基本信息:			包括类访问控制符、类名称、父类引用、接口引用表
	  ② 类运行时常量池:		类执行时用到的常量
	  ③ 类字段表加载器:		用于加载类字段(类属性)的信息，如字段名称、字段修饰、字段id等
	  ④ 类方法加载器:		用于加载类方法信息，如方法名、方法指令表(JVM根据指令表指令执行方法)、方法栈深等
	  ⑤ 方法区引用:			存放方法区引用
	  ⑥ 类静态变量表:		存放类静态变量
	  ⑦ 类初始化标识符:		标记是类是否被初始化。若未被初始化，则调用类构造器(<clinit>)方法初始化类

	(3).在堆区生成对应类

  2.验证:该步骤省去

  3.准备:
    然后主要完成如下工作

    ① 字段数(字段id)计算:
	字段数用途:		对象根据字段id从类或对象的变量表获取数据。如Student类对象std1,std1.name="xiaoming"。
	若想获取std1的name属性，首先要获取Student类name属性的字段id。根据字段id在std1的变量表获取信息

	根据字段的字段描述完成静态和实例的字段id计算
 
	② 分配并初始化类静态变量表
	创建类静态变量表，将变量表引用设置为空，数值设置为0

	③ 初始化常量字段(final static):
	根据常量字段的常量字段索引(constValueIndex)加载运行时常量池 constPool 的常量。
	根据静态字段id给类静态变量表 staticVars 赋值。
	如:Student类有字段 final static int age=16;
	数值16是constPool的第2个元素(即age的constValueIndex=2),age字段id=3
	则Student的 staticVars[age字段id] = constPool[age的constValueIndex]
	即staticVars[3] = constPool[2] = 16

  4.解析:
    将符号引用替换为直接引用。比如:
	方法引用methodRef* a，有属性method。一开始的时候a->method是空的
	而解析就是解析methodRef得到方法methodA，然后令a->method=methodA

	jvm遍历运行时常量池，解析类引用、字段引用和方法引用
	这里只是附和jvm类加载机制，我觉得按需加载比较好
	即用到某个符号引用再将其解析为直接引用。这样做可以不必解析一堆可能用不到的引用
	提高jvm效率，节约jvm内存

	解析时，为部分解析:
	只有当某个符号引用所属的类已经在方法区时才对其进行解析
	比如某方法引用methodRef* b，这个方法引用的方法属于类B。
	只有当类B已经在方法区时才对b进行解析。

	原因:
	如果类B不在方法区的话，若对方法引用b进行解析，就会触发类B的加载
	就会触发类B的解析。若解析时类B某个符号引用的类C也不在方法区，又会触发类C的加载
	类C加载又会触发类C解析，若类C某个符号引用的类D不在方法区，又会触发类D加载...

	这样jvm就会花费大量时间用于加载类，方法区花费大量内存存放这些类
	但实际上可能根本不会用到方法引用b！


  5.初始化(懒初始化)
    执行到new、putStatic、getStatic、invokeStatic指令的时候，
	调用该类的类初始化方法(clinit)初始化类
	这里我称为懒初始化，和bean的懒加载很像

完成上述工作后，会返回MethodAreaClass(方法区类)。方法区将这些信息通过键值对的方式进行保存
key:类限定全称名	value:MethodAreaClass
