******************************************
* 运行时数据区                           *
******************************************

一.功能
  管理类信息(方法区)和对象(堆区)以及字符串常量(字符串常量池)

二.主要数据类型
  1.方法区(MethodArea)			用于管理方法区类
  2.堆区(Heap)					用于分配和管理对象。分为(1)TO区	(2)FORM区	(3)老年区
  3.字符串常量池(String Pool)	管理字符串常量

三.内存模型

     +-------------------+            +---------------------------------+         +---------------------------+
	 | 堆区(Heap)        |            | 方法区(MethodArea)              |         | 字符串常量池(String Pool) |
	 |-------------------|            |---------------------------------|         |---------------------------|
	 | +---------------+ |            | +-----------------------------+ |         | +-----------------------+ |
	 | | 对象(Object)1 | |       =====+>| key: 类A全称类名(包名/类名) | |         | | key	键(字符串)      | |
	 | |---------------| |       #    | |-----------------------------| |         | |-----------------------| |
	 | |               | |  ======    | | value:类(MethodAreaClass) A | |      ===+=| value	值(字符串对象)  | |
	 | | 对象名        | |  #         | |                             | |      #  | +-----------------------+ |
	 | | 对象所属类    |=+===         | | 类A字段加载器               | |      #  |                           |
     | | 对象变量表    | |            | | 类A方法加载器               | |      #  | +-----------------------+ |
	 | | 对象年龄      | |            | | 类A父类(指向类B)            |=+===   #  | | key                   | |
	 | | 对象存活标记  | |            | | 类A初始化标识符			  | |  #   #  | |-----------------------| |
	 | | 其他属性...   | |            | | 类A其他属性                 | |  #   #  | | value                 | |
	 | +---------------+ |            | +-----------------------------+ |  #   #  | +-----------------------+ |
	 |                   |            |                                 |  #   #  |                           |
	 | +---------------+ |            | +-----------------------------+ |  #   #  | 其他字符串常量...	      |
	 | | 对象2(字符串) |<+=====       | | key: 类B全称类名            | |  #   #  +---------------------------+
	 | |---------------| |    #       | |-----------------------------| |  #   # 
	 | | 对象2属性...  | |    #       | | value:类B(类B是类A父类)     |<+===   #
	 | +---------------+ |    #       | +-----------------------------+ |      #
     |                   |    #       |                                 |      #
	 | 其他对象...       |    #       |  其他方法区类...                |      #
	 +-------------------+    #       +---------------------------------+      #
                              =================================================#

四.对象创建

  1.对象创建相关指令:
    (1) new				创建引用类型对象
	(2) newarray		创建一维数组(基本类型)对象
	(3) anewarray		创建一维数组(引用类型)对象
	(4) multianewarray	创建多维数组对象

  2.创建对象流程
  假设创建类A对象
    (1) 方法执行到new指令
	(2) 根据索引从常量池获取类A引用
	(3) 解析类A引用，获取方法区类A。方法区根据类A全称类名获取类信息
	(4) 根据类初始化标识符决定是否调用类构造方法初始化类
	(5) 根据类A信息分配堆区空间构建类A对象，初始化类A变量表。空间不足则开启GC进行回收
	(6) 创建完成，在堆区记录该对象的对象头地址以便日后回收

   创建数组对象流程同上

五.对象字段赋值与获取
  假设有类Student。Student有字段name、age等信息。现有对象std1

  1.如何给std1的name赋值为"xiaoming"?
	(1) 创建字符串对象"xiaoming",压入操作数栈
    (2) 获取std1的类Student。根据Student的字段表获取字段name的字段id
	(3) 操作数栈弹出字符串对象"xiaoming"，根据将std1变量表[字段id]赋值为字符串对象"xiaoming"
  
  2.如何获取std1的name字段?
    (1) 获取std1的类Student。根据Student的字段表获取字段name的字段id
	(2) 将std1[字段id]的信息压入操作数栈

六.字符串常量池

  存放字符串常量，提高内存利用率。创建字符串对象时先看字符串池有没有，没有就创建，有就返回引用
  比如有字符串"ABC"。String A = "ABC";String B = "ABC";String C = "ABC";
  则实际上A、B、C都指向了字符串常量池的"ABC"
  String A ---|
  String B ---|-->字符串常量池对象"ABC"
  String C ---|

  1.String A = "ABC" 与 String B = new String("ABC")的区别
    对于"ABC"来说都是作为UTF8(字面量)存放在运行时常量池里

    (1) String A = "ABC": 通过ldc指令从常量池加载了字面量"ABC"。在字符串池创建String对象"ABC"后将该对象引用赋值给A
	    所以只是创建了一个对象
	(2) String B = new String("ABC"): 同上，也是通过ldc加载了字面量"ABC"并在字符串常量池创建对象。
	    不同的是还通过new String创建了一个字符串对象。这个字符串对象的value指向字符串池对象"ABC"的value
		所以是创建了两个对象

	       引用                 堆区               字符串常量池        
         String A ----------------------------> 常量池字符串对象"ABC" 
	     String B --------> 堆区字符串对象         |---[value]字段-----|
		                     |---[value字段]                           |
							         |------>  char数组 内容 "ABC"  <--|
	 													
七.堆区回收

    1.堆区空间结构
	  (1) 新生代   ① TO区   ② FORM区
	  (2) 老年代
	  TO区 : FORM区 : 老年代 = 1 : 1 : 4

	2.回收方式
	  (1) 新生代 采用可达算法分析标记存活对象 + Serial回收器(复制算法)回收存活对象

	2.回收流程
	  (1) 保存堆区对象之间的引用关系
	  (2) 遍历操作数栈、本地变量表和类静态字段表。将里面引用的对象作为GC根节点
	      因为这些对象被操作数栈、本地变量表、类静态字段表引用了，说明后面可能还会用到，不能回收
	  (3) 对所有GC根节点进行遍历，寻找这些被GC根节点直接或间接引用的对象，标记为存活
	      因为被GC根节点直接或间接引用的对象后面可能会用到，不能回收
	      比如GC根节点对象A引用了对象B，对象B引用了对象C。则A,B,C对象均为存活
	  (4) 将存活对象进行如下操作
	      ① 若对象年龄达到进入老年代的标准，则将对象复制到老年代
		  ② 反之，将对象复制到备用内存区。比如当前使用的内存区为TO，那就复制到FORM，反之则复制到TO
	  (5) 恢复GC前对象之间的引用关系